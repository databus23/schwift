/*******************************************************************************
*
* THIS FILE IS AUTOGENERATED.
*
* Edit `generated.go.in` instead and run `make generate` to produce this file.
*
*******************************************************************************/

package schwift

import (
	"net/textproto"

	"github.com/majewsky/schwift/headers"
)

//AccountHeaders contains the headers for a schwift.Account instance.
//
//To read and write well-known headers, use the methods on this type.
//To read and write arbitary headers, use the methods on type Headers.
type AccountHeaders map[string]string

//Clear sets the value for the specified header to the empty string. When the
//Headers instance is then sent to the server with Update(), the server will
//delete the value for that header; cf. Del().
func (h AccountHeaders) Clear(key string) {
	h[textproto.CanonicalMIMEHeaderKey(key)] = ""
}

//Del deletes a key from the Headers instance. When the Headers instance
//is then sent to the server with Update(), Del() has different effects
//depending on context because of Swift's inconsistent API:
//
//For most writable attributes, a key which has been deleted with Del() will
//remain unchanged on the server. To remove the key on the server, use Clear()
//instead.
func (h AccountHeaders) Del(key string) {
	delete(h, textproto.CanonicalMIMEHeaderKey(key))
}

//Get returns the value for the specified header.
func (h AccountHeaders) Get(key string) string {
	return h[textproto.CanonicalMIMEHeaderKey(key)]
}

//Set sets a new value for the specified header. Any existing value will be
//overwritten.
func (h AccountHeaders) Set(key, value string) {
	h[textproto.CanonicalMIMEHeaderKey(key)] = value
}

//Validate returns headers.MalformedHeaderError if the value of any well-known
//header does not conform to its data type. This is called automatically by
//Schwift when preparing an AccountHeaders instance from a GET/HEAD response,
//so you usually do not need to do it yourself. You will get the validation error
//from the Account method doing the request, e.g. Headers().
func (h AccountHeaders) Validate() error {
	if err := h.BytesUsed().Validate(); err != nil {
		return err
	}
	if err := h.ContainerCount().Validate(); err != nil {
		return err
	}
	if err := h.QuotaBytes().Validate(); err != nil {
		return err
	}
	if err := h.ObjectCount().Validate(); err != nil {
		return err
	}
	if err := h.Timestamp().Validate(); err != nil {
		return err
	}
	return evadeGolintComplaint1()
}

//BytesUsed provides type-safe access to X-Account-Bytes-Used headers.
func (h AccountHeaders) BytesUsed() headers.Uint64Readonly {
	return headers.Uint64Readonly{
		Base: headers.Base{
			H: h,
			K: "X-Account-Bytes-Used",
		},
	}
}

//ContainerCount provides type-safe access to X-Account-Container-Count headers.
func (h AccountHeaders) ContainerCount() headers.Uint64Readonly {
	return headers.Uint64Readonly{
		Base: headers.Base{
			H: h,
			K: "X-Account-Container-Count",
		},
	}
}

//Metadata provides type-safe access to X-Account-Meta- headers.
func (h AccountHeaders) Metadata() headers.Metadata {
	return headers.Metadata{
		Base: headers.Base{
			H: h,
			K: "X-Account-Meta-",
		},
	}
}

//QuotaBytes provides type-safe access to X-Account-Meta-Quota-Bytes headers.
func (h AccountHeaders) QuotaBytes() headers.Uint64 {
	return headers.Uint64{
		Base: headers.Base{
			H: h,
			K: "X-Account-Meta-Quota-Bytes",
		},
	}
}

//TempURLKey2 provides type-safe access to X-Account-Meta-Temp-URL-Key-2 headers.
func (h AccountHeaders) TempURLKey2() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Account-Meta-Temp-URL-Key-2",
		},
	}
}

//TempURLKey provides type-safe access to X-Account-Meta-Temp-URL-Key headers.
func (h AccountHeaders) TempURLKey() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Account-Meta-Temp-URL-Key",
		},
	}
}

//ObjectCount provides type-safe access to X-Account-Object-Count headers.
func (h AccountHeaders) ObjectCount() headers.Uint64Readonly {
	return headers.Uint64Readonly{
		Base: headers.Base{
			H: h,
			K: "X-Account-Object-Count",
		},
	}
}

//Timestamp provides type-safe access to X-Timestamp headers.
func (h AccountHeaders) Timestamp() headers.UnixTimeReadonly {
	return headers.UnixTimeReadonly{
		Base: headers.Base{
			H: h,
			K: "X-Timestamp",
		},
	}
}

//ContainerHeaders contains the headers for a schwift.Container instance.
//
//To read and write well-known headers, use the methods on this type.
//To read and write arbitary headers, use the methods on type Headers.
type ContainerHeaders map[string]string

//Clear sets the value for the specified header to the empty string. When the
//Headers instance is then sent to the server with Update(), the server will
//delete the value for that header; cf. Del().
func (h ContainerHeaders) Clear(key string) {
	h[textproto.CanonicalMIMEHeaderKey(key)] = ""
}

//Del deletes a key from the Headers instance. When the Headers instance
//is then sent to the server with Update(), Del() has different effects
//depending on context because of Swift's inconsistent API:
//
//For most writable attributes, a key which has been deleted with Del() will
//remain unchanged on the server. To remove the key on the server, use Clear()
//instead.
func (h ContainerHeaders) Del(key string) {
	delete(h, textproto.CanonicalMIMEHeaderKey(key))
}

//Get returns the value for the specified header.
func (h ContainerHeaders) Get(key string) string {
	return h[textproto.CanonicalMIMEHeaderKey(key)]
}

//Set sets a new value for the specified header. Any existing value will be
//overwritten.
func (h ContainerHeaders) Set(key, value string) {
	h[textproto.CanonicalMIMEHeaderKey(key)] = value
}

//Validate returns headers.MalformedHeaderError if the value of any well-known
//header does not conform to its data type. This is called automatically by
//Schwift when preparing an ContainerHeaders instance from a GET/HEAD response,
//so you usually do not need to do it yourself. You will get the validation error
//from the Container method doing the request, e.g. Headers().
func (h ContainerHeaders) Validate() error {
	if err := h.BytesUsed().Validate(); err != nil {
		return err
	}
	if err := h.BytesUsedQuota().Validate(); err != nil {
		return err
	}
	if err := h.ObjectCountQuota().Validate(); err != nil {
		return err
	}
	if err := h.ObjectCount().Validate(); err != nil {
		return err
	}
	if err := h.Timestamp().Validate(); err != nil {
		return err
	}
	return evadeGolintComplaint1()
}

//BytesUsed provides type-safe access to X-Container-Bytes-Used headers.
func (h ContainerHeaders) BytesUsed() headers.Uint64Readonly {
	return headers.Uint64Readonly{
		Base: headers.Base{
			H: h,
			K: "X-Container-Bytes-Used",
		},
	}
}

//Metadata provides type-safe access to X-Container-Meta- headers.
func (h ContainerHeaders) Metadata() headers.Metadata {
	return headers.Metadata{
		Base: headers.Base{
			H: h,
			K: "X-Container-Meta-",
		},
	}
}

//BytesUsedQuota provides type-safe access to X-Container-Meta-Quota-Bytes headers.
func (h ContainerHeaders) BytesUsedQuota() headers.Uint64 {
	return headers.Uint64{
		Base: headers.Base{
			H: h,
			K: "X-Container-Meta-Quota-Bytes",
		},
	}
}

//ObjectCountQuota provides type-safe access to X-Container-Meta-Quota-Count headers.
func (h ContainerHeaders) ObjectCountQuota() headers.Uint64 {
	return headers.Uint64{
		Base: headers.Base{
			H: h,
			K: "X-Container-Meta-Quota-Count",
		},
	}
}

//TempURLKey2 provides type-safe access to X-Container-Meta-Temp-URL-Key-2 headers.
func (h ContainerHeaders) TempURLKey2() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Container-Meta-Temp-URL-Key-2",
		},
	}
}

//TempURLKey provides type-safe access to X-Container-Meta-Temp-URL-Key headers.
func (h ContainerHeaders) TempURLKey() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Container-Meta-Temp-URL-Key",
		},
	}
}

//ObjectCount provides type-safe access to X-Container-Object-Count headers.
func (h ContainerHeaders) ObjectCount() headers.Uint64Readonly {
	return headers.Uint64Readonly{
		Base: headers.Base{
			H: h,
			K: "X-Container-Object-Count",
		},
	}
}

//ReadACL provides type-safe access to X-Container-Read headers.
func (h ContainerHeaders) ReadACL() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Container-Read",
		},
	}
}

//SyncKey provides type-safe access to X-Container-Sync-Key headers.
func (h ContainerHeaders) SyncKey() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Container-Sync-Key",
		},
	}
}

//SyncTo provides type-safe access to X-Container-Sync-To headers.
func (h ContainerHeaders) SyncTo() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Container-Sync-To",
		},
	}
}

//WriteACL provides type-safe access to X-Container-Write headers.
func (h ContainerHeaders) WriteACL() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Container-Write",
		},
	}
}

//HistoryLocation provides type-safe access to X-History-Location headers.
func (h ContainerHeaders) HistoryLocation() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-History-Location",
		},
	}
}

//StoragePolicy provides type-safe access to X-Storage-Policy headers.
func (h ContainerHeaders) StoragePolicy() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Storage-Policy",
		},
	}
}

//Timestamp provides type-safe access to X-Timestamp headers.
func (h ContainerHeaders) Timestamp() headers.UnixTimeReadonly {
	return headers.UnixTimeReadonly{
		Base: headers.Base{
			H: h,
			K: "X-Timestamp",
		},
	}
}

//VersionsLocation provides type-safe access to X-Versions-Location headers.
func (h ContainerHeaders) VersionsLocation() headers.String {
	return headers.String{
		Base: headers.Base{
			H: h,
			K: "X-Versions-Location",
		},
	}
}

func evadeGolintComplaint1() error {
	return nil
}
