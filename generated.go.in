{
	"Account": {
		"Fields": [
			{ "Header": "X-Account-Bytes-Used", "Attribute": "BytesUsed", "Type": "Uint64Readonly" },
			{ "Header": "X-Account-Container-Count", "Attribute": "ContainerCount", "Type": "Uint64Readonly" },
			{ "Header": "X-Account-Meta-", "Attribute": "Metadata", "Type": "Metadata" },
			{ "Header": "X-Account-Meta-Quota-Bytes", "Attribute": "QuotaBytes", "Type": "Uint64" },
			{ "Header": "X-Account-Meta-Temp-URL-Key-2", "Attribute": "TempURLKey2", "Type": "String" },
			{ "Header": "X-Account-Meta-Temp-URL-Key", "Attribute": "TempURLKey", "Type": "String" },
			{ "Header": "X-Account-Object-Count", "Attribute": "ObjectCount", "Type": "Uint64Readonly" },
			{ "Header": "X-Timestamp", "Attribute": "Timestamp", "Type": "UnixTimeReadonly" }
		]
	},
	"Container": {
		"Fields": [
			{ "Header": "X-Container-Bytes-Used", "Attribute": "BytesUsed", "Type": "Uint64Readonly" },
			{ "Header": "X-Container-Meta-", "Attribute": "Metadata", "Type": "Metadata" },
			{ "Header": "X-Container-Meta-Quota-Bytes", "Attribute": "BytesUsedQuota", "Type": "Uint64" },
			{ "Header": "X-Container-Meta-Quota-Count", "Attribute": "ObjectCountQuota", "Type": "Uint64" },
			{ "Header": "X-Container-Meta-Temp-URL-Key-2", "Attribute": "TempURLKey2", "Type": "String" },
			{ "Header": "X-Container-Meta-Temp-URL-Key", "Attribute": "TempURLKey", "Type": "String" },
			{ "Header": "X-Container-Object-Count", "Attribute": "ObjectCount", "Type": "Uint64Readonly" },
			{ "Header": "X-Container-Read", "Attribute": "ReadACL", "Type": "String" },
			{ "Header": "X-Container-Sync-Key", "Attribute": "SyncKey", "Type": "String" },
			{ "Header": "X-Container-Sync-To", "Attribute": "SyncTo", "Type": "String" },
			{ "Header": "X-Container-Write", "Attribute": "WriteACL", "Type": "String" },
			{ "Header": "X-History-Location", "Attribute": "HistoryLocation", "Type": "String" },
			{ "Header": "X-Storage-Policy", "Attribute": "StoragePolicy", "Type": "String" },
			{ "Header": "X-Timestamp", "Attribute": "Timestamp", "Type": "UnixTimeReadonly" },
			{ "Header": "X-Versions-Location", "Attribute": "VersionsLocation", "Type": "String" }
		]
	}
}
---
/*******************************************************************************
*
* THIS FILE IS AUTOGENERATED.
*
* Edit `generated.go.in` instead and run `make generate` to produce this file.
*
*******************************************************************************/

package schwift

import "net/textproto"

{{- range $htype, $hmeta := . }}

//{{$htype}}Headers contains the headers for a schwift.{{$htype}} instance.
//
//To read and write well-known headers, use the methods on this type.
//To read and write arbitary headers, use the http.Header-like methods Get(),
//Set(), Clear(), Del().
type {{$htype}}Headers map[string]string

//Clear sets the value for the specified header to the empty string. When the
//Headers instance is then sent to the server with Update(), the server will
//delete the value for that header; cf. Del().
func (h {{$htype}}Headers) Clear(key string) {
	h[textproto.CanonicalMIMEHeaderKey(key)] = ""
}

//Del deletes a key from the Headers instance. When the Headers instance
//is then sent to the server with Update(), Del() has different effects
//depending on context because of Swift's inconsistent API:
//
//For most writable attributes, a key which has been deleted with Del() will
//remain unchanged on the server. To remove the key on the server, use Clear()
//instead.
{{- if eq $htype "Object" }}
//
//For object metadata (but not other object attributes), deleting a key will
//cause that key to be deleted on the server. Del() is identical to Clear() in
//this case.
{{- end }}
func (h {{$htype}}Headers) Del(key string) {
	delete(h, textproto.CanonicalMIMEHeaderKey(key))
}

//Get returns the value for the specified header.
func (h {{$htype}}Headers) Get(key string) string {
	return h[textproto.CanonicalMIMEHeaderKey(key)]
}

//Set sets a new value for the specified header. Any existing value will be
//overwritten.
func (h {{$htype}}Headers) Set(key, value string) {
	h[textproto.CanonicalMIMEHeaderKey(key)] = value
}

//Validate returns MalformedHeaderError if the value of any well-known header
//does not conform to its data type. This is called automatically by Schwift
//when preparing an {{$htype}}Headers instance from a GET/HEAD response, so you
//usually do not need to do it yourself. You will get the validation error from
//the {{$htype}} method doing the request, e.g. Headers().
func (h {{$htype}}Headers) Validate() error {
{{- range $field := $hmeta.Fields }}
	if err := h.{{$field.Attribute}}().validate(); err != nil {
		return err
	}
{{- end }}
	return evadeGolintComplaint1()
}

{{- range $field := $hmeta.Fields }}

//{{$field.Attribute}} provides type-safe access to {{$field.Header}} headers.
func (h {{$htype}}Headers) {{$field.Attribute}}() Field{{$field.Type}} {
	return Field{{$field.Type}}{h, "{{$field.Header}}"}
}
{{- end }}
{{- end }}

func evadeGolintComplaint1() error {
	return nil
}
